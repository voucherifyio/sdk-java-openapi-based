/*
 * Voucherify API
 * Voucherify promotion engine REST API. Please see https://docs.voucherify.io/docs for more details.
 *
 * The version of the OpenAPI document: v2018-08-01
 * Contact: support@voucherify.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.voucherify.client.api;

import io.voucherify.client.ApiCallback;
import io.voucherify.client.ApiClient;
import io.voucherify.client.ApiException;
import io.voucherify.client.ApiResponse;
import io.voucherify.client.Configuration;
import io.voucherify.client.Pair;
import io.voucherify.client.ProgressRequestBody;
import io.voucherify.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.voucherify.client.model.CustomersCreateRequestBody;
import io.voucherify.client.model.CustomersCreateResponseBody;
import io.voucherify.client.model.CustomersGetResponseBody;
import io.voucherify.client.model.CustomersImportCsvCreateResponseBody;
import io.voucherify.client.model.CustomersListResponseBody;
import io.voucherify.client.model.CustomersMetadataUpdateInBulkRequestBody;
import io.voucherify.client.model.CustomersMetadataUpdateInBulkResponseBody;
import io.voucherify.client.model.CustomersPermanentDeletionCreateResponseBody;
import io.voucherify.client.model.CustomersSegmentsListResponseBody;
import io.voucherify.client.model.CustomersUpdateInBulkRequestBody;
import io.voucherify.client.model.CustomersUpdateInBulkResponseBody;
import io.voucherify.client.model.CustomersUpdateRequestBody;
import io.voucherify.client.model.CustomersUpdateResponseBody;
import java.io.File;
import java.time.OffsetDateTime;
import io.voucherify.client.model.ParameterOrderListCustomers;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CustomersApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CustomersApi() {
        this(Configuration.getDefaultApiClient());
    }

    public CustomersApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for createCustomer
     * @param customersCreateRequestBody Create a customer with specified parameters. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCustomerCall(CustomersCreateRequestBody customersCreateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customersCreateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/customers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCustomerValidateBeforeCall(CustomersCreateRequestBody customersCreateRequestBody, final ApiCallback _callback) throws ApiException {
        return createCustomerCall(customersCreateRequestBody, _callback);

    }

    /**
     * Create Customer
     * Creates a customer object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the customer database, Voucherify will return a related customer object with updated fields.
     * @param customersCreateRequestBody Create a customer with specified parameters. (optional)
     * @return CustomersCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersCreateResponseBody createCustomer(CustomersCreateRequestBody customersCreateRequestBody) throws ApiException {
        ApiResponse<CustomersCreateResponseBody> localVarResp = createCustomerWithHttpInfo(customersCreateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Create Customer
     * Creates a customer object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the customer database, Voucherify will return a related customer object with updated fields.
     * @param customersCreateRequestBody Create a customer with specified parameters. (optional)
     * @return ApiResponse&lt;CustomersCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersCreateResponseBody> createCustomerWithHttpInfo(CustomersCreateRequestBody customersCreateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = createCustomerValidateBeforeCall(customersCreateRequestBody, null);
        Type localVarReturnType = new TypeToken<CustomersCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Customer (asynchronously)
     * Creates a customer object.  &lt;!-- theme: info --&gt;  &gt; ðŸ“˜ Upsert Mode &gt; &gt; If you pass an &#x60;id&#x60; or a &#x60;source_id&#x60; that already exists in the customer database, Voucherify will return a related customer object with updated fields.
     * @param customersCreateRequestBody Create a customer with specified parameters. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createCustomerAsync(CustomersCreateRequestBody customersCreateRequestBody, final ApiCallback<CustomersCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = createCustomerValidateBeforeCall(customersCreateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<CustomersCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for customerPermanentlyDeletion
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a permanent deletion object and status of the deletion. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call customerPermanentlyDeletionCall(String customerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}/permanent-deletion"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call customerPermanentlyDeletionValidateBeforeCall(String customerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling customerPermanentlyDeletion(Async)");
        }

        return customerPermanentlyDeletionCall(customerId, _callback);

    }

    /**
     * Delete Customer Permanently
     * The organization user can remove consumer data permanently from the Voucherify system by using this API method. It deletes all customer data and connected resources. It makes the customer profile forgotten by Voucherify.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @return CustomersPermanentDeletionCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a permanent deletion object and status of the deletion. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersPermanentDeletionCreateResponseBody customerPermanentlyDeletion(String customerId) throws ApiException {
        ApiResponse<CustomersPermanentDeletionCreateResponseBody> localVarResp = customerPermanentlyDeletionWithHttpInfo(customerId);
        return localVarResp.getData();
    }

    /**
     * Delete Customer Permanently
     * The organization user can remove consumer data permanently from the Voucherify system by using this API method. It deletes all customer data and connected resources. It makes the customer profile forgotten by Voucherify.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @return ApiResponse&lt;CustomersPermanentDeletionCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a permanent deletion object and status of the deletion. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersPermanentDeletionCreateResponseBody> customerPermanentlyDeletionWithHttpInfo(String customerId) throws ApiException {
        okhttp3.Call localVarCall = customerPermanentlyDeletionValidateBeforeCall(customerId, null);
        Type localVarReturnType = new TypeToken<CustomersPermanentDeletionCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Customer Permanently (asynchronously)
     * The organization user can remove consumer data permanently from the Voucherify system by using this API method. It deletes all customer data and connected resources. It makes the customer profile forgotten by Voucherify.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a permanent deletion object and status of the deletion. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call customerPermanentlyDeletionAsync(String customerId, final ApiCallback<CustomersPermanentDeletionCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = customerPermanentlyDeletionValidateBeforeCall(customerId, _callback);
        Type localVarReturnType = new TypeToken<CustomersPermanentDeletionCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCustomer
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCustomerCall(String customerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCustomerValidateBeforeCall(String customerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling deleteCustomer(Async)");
        }

        return deleteCustomerCall(customerId, _callback);

    }

    /**
     * Delete Customer
     * This method deletes a customer.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public void deleteCustomer(String customerId) throws ApiException {
        deleteCustomerWithHttpInfo(customerId);
    }

    /**
     * Delete Customer
     * This method deletes a customer.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteCustomerWithHttpInfo(String customerId) throws ApiException {
        okhttp3.Call localVarCall = deleteCustomerValidateBeforeCall(customerId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Customer (asynchronously)
     * This method deletes a customer.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if deletion is successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCustomerAsync(String customerId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteCustomerValidateBeforeCall(customerId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCustomer
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerCall(String customerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCustomerValidateBeforeCall(String customerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling getCustomer(Async)");
        }

        return getCustomerCall(customerId, _callback);

    }

    /**
     * Get Customer
     * Retrieve customer details.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @return CustomersGetResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersGetResponseBody getCustomer(String customerId) throws ApiException {
        ApiResponse<CustomersGetResponseBody> localVarResp = getCustomerWithHttpInfo(customerId);
        return localVarResp.getData();
    }

    /**
     * Get Customer
     * Retrieve customer details.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @return ApiResponse&lt;CustomersGetResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersGetResponseBody> getCustomerWithHttpInfo(String customerId) throws ApiException {
        okhttp3.Call localVarCall = getCustomerValidateBeforeCall(customerId, null);
        Type localVarReturnType = new TypeToken<CustomersGetResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Customer (asynchronously)
     * Retrieve customer details.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if a valid identifier was provided. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerAsync(String customerId, final ApiCallback<CustomersGetResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCustomerValidateBeforeCall(customerId, _callback);
        Type localVarReturnType = new TypeToken<CustomersGetResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importCustomersUsingCsv
     * @param _file File path. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importCustomersUsingCsvCall(File _file, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers/importCSV";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (_file != null) {
            localVarFormParams.put("file", _file);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importCustomersUsingCsvValidateBeforeCall(File _file, final ApiCallback _callback) throws ApiException {
        return importCustomersUsingCsvCall(_file, _callback);

    }

    /**
     * Import and Update Customers using CSV
     * This API method lets you import or update customer data. To get a proper and valid response, please send a CSV file with data separated by commas.    ## Request Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/customers/importCSV \\   -F file&#x3D;@/path/to/customers.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; ## CSV File Format  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard customer fields will be added to the metadata object.  &lt;!-- theme: info --&gt; &gt; ðŸ“˜ Standard customer fields mapping &gt; &gt; **No spaces allowed in field names**   &gt; Id, Name, Email, Phone, Birthdate, Source_id, Address_line_1, Address_line_2, Address_Postal_Code, Address_City, Address_State, Address_Country, Description, Metadata_name_1, Metadata_name_2  ## Update Customers using CSV  If you would like to update customer&#39;s data, you can do it using the CSV file with new data. However, remember to include a &#x60;source_id&#x60; in your CSV file to manage the update successfully.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return CustomersImportCsvCreateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersImportCsvCreateResponseBody importCustomersUsingCsv(File _file) throws ApiException {
        ApiResponse<CustomersImportCsvCreateResponseBody> localVarResp = importCustomersUsingCsvWithHttpInfo(_file);
        return localVarResp.getData();
    }

    /**
     * Import and Update Customers using CSV
     * This API method lets you import or update customer data. To get a proper and valid response, please send a CSV file with data separated by commas.    ## Request Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/customers/importCSV \\   -F file&#x3D;@/path/to/customers.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; ## CSV File Format  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard customer fields will be added to the metadata object.  &lt;!-- theme: info --&gt; &gt; ðŸ“˜ Standard customer fields mapping &gt; &gt; **No spaces allowed in field names**   &gt; Id, Name, Email, Phone, Birthdate, Source_id, Address_line_1, Address_line_2, Address_Postal_Code, Address_City, Address_State, Address_Country, Description, Metadata_name_1, Metadata_name_2  ## Update Customers using CSV  If you would like to update customer&#39;s data, you can do it using the CSV file with new data. However, remember to include a &#x60;source_id&#x60; in your CSV file to manage the update successfully.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @return ApiResponse&lt;CustomersImportCsvCreateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersImportCsvCreateResponseBody> importCustomersUsingCsvWithHttpInfo(File _file) throws ApiException {
        okhttp3.Call localVarCall = importCustomersUsingCsvValidateBeforeCall(_file, null);
        Type localVarReturnType = new TypeToken<CustomersImportCsvCreateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Import and Update Customers using CSV (asynchronously)
     * This API method lets you import or update customer data. To get a proper and valid response, please send a CSV file with data separated by commas.    ## Request Example &lt;!-- title: \&quot;Example Request\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;cURL curl -X POST \\   https://api.voucherify.io/v1/customers/importCSV \\   -F file&#x3D;@/path/to/customers.csv \\   -H \&quot;X-App-Id: c70a6f00-cf91-4756-9df5-47628850002b\&quot; \\   -H \&quot;X-App-Token: 3266b9f8-e246-4f79-bdf0-833929b1380c\&quot; &#x60;&#x60;&#x60; ## CSV File Format  The CSV file has to include headers in the first line. All properties which cannot be mapped to standard customer fields will be added to the metadata object.  &lt;!-- theme: info --&gt; &gt; ðŸ“˜ Standard customer fields mapping &gt; &gt; **No spaces allowed in field names**   &gt; Id, Name, Email, Phone, Birthdate, Source_id, Address_line_1, Address_line_2, Address_Postal_Code, Address_City, Address_State, Address_Country, Description, Metadata_name_1, Metadata_name_2  ## Update Customers using CSV  If you would like to update customer&#39;s data, you can do it using the CSV file with new data. However, remember to include a &#x60;source_id&#x60; in your CSV file to manage the update successfully.  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param _file File path. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be added to the repository asynchronously. To check the import status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call importCustomersUsingCsvAsync(File _file, final ApiCallback<CustomersImportCsvCreateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = importCustomersUsingCsvValidateBeforeCall(_file, _callback);
        Type localVarReturnType = new TypeToken<CustomersImportCsvCreateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listCustomerSegments
     * @param customerId Unique identifier of a customer represented by an internal customer ID or customer source ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The method returns segment(s) to which the given customer belongs to. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCustomerSegmentsCall(String customerId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}/segments"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCustomerSegmentsValidateBeforeCall(String customerId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling listCustomerSegments(Async)");
        }

        return listCustomerSegmentsCall(customerId, _callback);

    }

    /**
     * List Customer&#39;s Segments
     * Returns the list of segments IDs to which the customer belongs to.    If you pass a &#x60;customerId&#x60; which is not stored and recognized by Voucherify as an existing customer in the system, the response will generate a list of segments that the customer would potentialy qualify for if they were to become a customer tracked in the system.
     * @param customerId Unique identifier of a customer represented by an internal customer ID or customer source ID. (required)
     * @return CustomersSegmentsListResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The method returns segment(s) to which the given customer belongs to. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersSegmentsListResponseBody listCustomerSegments(String customerId) throws ApiException {
        ApiResponse<CustomersSegmentsListResponseBody> localVarResp = listCustomerSegmentsWithHttpInfo(customerId);
        return localVarResp.getData();
    }

    /**
     * List Customer&#39;s Segments
     * Returns the list of segments IDs to which the customer belongs to.    If you pass a &#x60;customerId&#x60; which is not stored and recognized by Voucherify as an existing customer in the system, the response will generate a list of segments that the customer would potentialy qualify for if they were to become a customer tracked in the system.
     * @param customerId Unique identifier of a customer represented by an internal customer ID or customer source ID. (required)
     * @return ApiResponse&lt;CustomersSegmentsListResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The method returns segment(s) to which the given customer belongs to. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersSegmentsListResponseBody> listCustomerSegmentsWithHttpInfo(String customerId) throws ApiException {
        okhttp3.Call localVarCall = listCustomerSegmentsValidateBeforeCall(customerId, null);
        Type localVarReturnType = new TypeToken<CustomersSegmentsListResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Customer&#39;s Segments (asynchronously)
     * Returns the list of segments IDs to which the customer belongs to.    If you pass a &#x60;customerId&#x60; which is not stored and recognized by Voucherify as an existing customer in the system, the response will generate a list of segments that the customer would potentialy qualify for if they were to become a customer tracked in the system.
     * @param customerId Unique identifier of a customer represented by an internal customer ID or customer source ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The method returns segment(s) to which the given customer belongs to. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCustomerSegmentsAsync(String customerId, final ApiCallback<CustomersSegmentsListResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = listCustomerSegmentsValidateBeforeCall(customerId, _callback);
        Type localVarReturnType = new TypeToken<CustomersSegmentsListResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listCustomers
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param email Limit the customers to the ones that have this specific email address. (optional)
     * @param city Limit the customers to the ones that are located in the specified city. (optional)
     * @param name Filter customers by the name property. (optional)
     * @param segmentId Filter customers by the segment id. (optional)
     * @param createdAtBefore Filter customers by date customer was created. (optional)
     * @param createdAtAfter Filter customers by date customer was created. (optional)
     * @param updatedAtBefore Filter customers by date customer was updated last time. (optional)
     * @param updatedAtAfter Filter customers by date customer was updated last time. (optional)
     * @param order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startingAfter A cursor for pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. |  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with customer objects. The customers are returned sorted by creation date, with the most recent customers appearing first. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCustomersCall(Integer limit, Integer page, String email, String city, String name, String segmentId, OffsetDateTime createdAtBefore, OffsetDateTime createdAtAfter, OffsetDateTime updatedAtBefore, OffsetDateTime updatedAtAfter, ParameterOrderListCustomers order, OffsetDateTime startingAfter, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/customers";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (email != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email", email));
        }

        if (city != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("city", city));
        }

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (segmentId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("segment_id", segmentId));
        }

        if (createdAtBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at[before]", createdAtBefore));
        }

        if (createdAtAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("created_at[after]", createdAtAfter));
        }

        if (updatedAtBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updated_at[before]", updatedAtBefore));
        }

        if (updatedAtAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("updated_at[after]", updatedAtAfter));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (startingAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("starting_after", startingAfter));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCustomersValidateBeforeCall(Integer limit, Integer page, String email, String city, String name, String segmentId, OffsetDateTime createdAtBefore, OffsetDateTime createdAtAfter, OffsetDateTime updatedAtBefore, OffsetDateTime updatedAtAfter, ParameterOrderListCustomers order, OffsetDateTime startingAfter, final ApiCallback _callback) throws ApiException {
        return listCustomersCall(limit, page, email, city, name, segmentId, createdAtBefore, createdAtAfter, updatedAtBefore, updatedAtAfter, order, startingAfter, _callback);

    }

    /**
     * List Customers
     * Returns a list of customers.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param email Limit the customers to the ones that have this specific email address. (optional)
     * @param city Limit the customers to the ones that are located in the specified city. (optional)
     * @param name Filter customers by the name property. (optional)
     * @param segmentId Filter customers by the segment id. (optional)
     * @param createdAtBefore Filter customers by date customer was created. (optional)
     * @param createdAtAfter Filter customers by date customer was created. (optional)
     * @param updatedAtBefore Filter customers by date customer was updated last time. (optional)
     * @param updatedAtAfter Filter customers by date customer was updated last time. (optional)
     * @param order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startingAfter A cursor for pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. |  (optional)
     * @return CustomersListResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with customer objects. The customers are returned sorted by creation date, with the most recent customers appearing first. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersListResponseBody listCustomers(Integer limit, Integer page, String email, String city, String name, String segmentId, OffsetDateTime createdAtBefore, OffsetDateTime createdAtAfter, OffsetDateTime updatedAtBefore, OffsetDateTime updatedAtAfter, ParameterOrderListCustomers order, OffsetDateTime startingAfter) throws ApiException {
        ApiResponse<CustomersListResponseBody> localVarResp = listCustomersWithHttpInfo(limit, page, email, city, name, segmentId, createdAtBefore, createdAtAfter, updatedAtBefore, updatedAtAfter, order, startingAfter);
        return localVarResp.getData();
    }

    /**
     * List Customers
     * Returns a list of customers.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param email Limit the customers to the ones that have this specific email address. (optional)
     * @param city Limit the customers to the ones that are located in the specified city. (optional)
     * @param name Filter customers by the name property. (optional)
     * @param segmentId Filter customers by the segment id. (optional)
     * @param createdAtBefore Filter customers by date customer was created. (optional)
     * @param createdAtAfter Filter customers by date customer was created. (optional)
     * @param updatedAtBefore Filter customers by date customer was updated last time. (optional)
     * @param updatedAtAfter Filter customers by date customer was updated last time. (optional)
     * @param order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startingAfter A cursor for pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. |  (optional)
     * @return ApiResponse&lt;CustomersListResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with customer objects. The customers are returned sorted by creation date, with the most recent customers appearing first. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersListResponseBody> listCustomersWithHttpInfo(Integer limit, Integer page, String email, String city, String name, String segmentId, OffsetDateTime createdAtBefore, OffsetDateTime createdAtAfter, OffsetDateTime updatedAtBefore, OffsetDateTime updatedAtAfter, ParameterOrderListCustomers order, OffsetDateTime startingAfter) throws ApiException {
        okhttp3.Call localVarCall = listCustomersValidateBeforeCall(limit, page, email, city, name, segmentId, createdAtBefore, createdAtAfter, updatedAtBefore, updatedAtAfter, order, startingAfter, null);
        Type localVarReturnType = new TypeToken<CustomersListResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Customers (asynchronously)
     * Returns a list of customers.
     * @param limit Limits the number of objects to be returned. The limit can range between 1 and 100 items. If no limit is set, it returns 10 items. (optional)
     * @param page Which page of results to return. The lowest value is &#x60;1&#x60;. (optional)
     * @param email Limit the customers to the ones that have this specific email address. (optional)
     * @param city Limit the customers to the ones that are located in the specified city. (optional)
     * @param name Filter customers by the name property. (optional)
     * @param segmentId Filter customers by the segment id. (optional)
     * @param createdAtBefore Filter customers by date customer was created. (optional)
     * @param createdAtAfter Filter customers by date customer was created. (optional)
     * @param updatedAtBefore Filter customers by date customer was updated last time. (optional)
     * @param updatedAtAfter Filter customers by date customer was updated last time. (optional)
     * @param order This is a property that controls the sorting direction of the results. Sort the results using one of the filtering options, where the dash &#x60;-&#x60; preceding a sorting option means sorting in a descending order. (optional)
     * @param startingAfter A cursor for pagination. This is a date-time value that defines your place in the list based on &#x60;created_at&#x60; property from the customer object. For instance, if you make a list request and receive 100 objects, ending with an object created at &#x60;2020-05-24T13:43:09.024Z&#x60;, your subsequent call can include &#x60;starting_after&#x3D;2020-05-24T13:43:09.024Z&#x60; in order to fetch the next page of the list.  &lt;!-- title: Options --&gt; | **Option** | **Format** | **Sorting** | |:---|:---|:---| | Return customers **before** a specific creation date  | - set &#x60;starting_after&#x60; parameter to the breakpoint date | Sorting order is **descending**; the most recent dates first and least recent dates last. | | Return customers **after** a specific create or update date | - include the &#x60;order&#x60; parameter set to &#x60;created_at&#x60; or &#x60;updated_at&#x60;&lt;br&gt;- set &#x60;starting_after&#x60; to the breakpoint date | Sorting order is **ascending**; the least recent dates first and the most recent dates last. |  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a dictionary with customer objects. The customers are returned sorted by creation date, with the most recent customers appearing first. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listCustomersAsync(Integer limit, Integer page, String email, String city, String name, String segmentId, OffsetDateTime createdAtBefore, OffsetDateTime createdAtAfter, OffsetDateTime updatedAtBefore, OffsetDateTime updatedAtAfter, ParameterOrderListCustomers order, OffsetDateTime startingAfter, final ApiCallback<CustomersListResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = listCustomersValidateBeforeCall(limit, page, email, city, name, segmentId, createdAtBefore, createdAtAfter, updatedAtBefore, updatedAtAfter, order, startingAfter, _callback);
        Type localVarReturnType = new TypeToken<CustomersListResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomer
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param customersUpdateRequestBody Specify the parameters to be updated. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if updates were successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomerCall(String customerId, CustomersUpdateRequestBody customersUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customersUpdateRequestBody;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomerValidateBeforeCall(String customerId, CustomersUpdateRequestBody customersUpdateRequestBody, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling updateCustomer(Async)");
        }

        return updateCustomerCall(customerId, customersUpdateRequestBody, _callback);

    }

    /**
     * Update Customer
     * Updates the specified customer by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param customersUpdateRequestBody Specify the parameters to be updated. (optional)
     * @return CustomersUpdateResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if updates were successful. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersUpdateResponseBody updateCustomer(String customerId, CustomersUpdateRequestBody customersUpdateRequestBody) throws ApiException {
        ApiResponse<CustomersUpdateResponseBody> localVarResp = updateCustomerWithHttpInfo(customerId, customersUpdateRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Customer
     * Updates the specified customer by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param customersUpdateRequestBody Specify the parameters to be updated. (optional)
     * @return ApiResponse&lt;CustomersUpdateResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if updates were successful. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersUpdateResponseBody> updateCustomerWithHttpInfo(String customerId, CustomersUpdateRequestBody customersUpdateRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateCustomerValidateBeforeCall(customerId, customersUpdateRequestBody, null);
        Type localVarReturnType = new TypeToken<CustomersUpdateResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Customer (asynchronously)
     * Updates the specified customer by setting the values of the parameters passed in the request body. Any parameters not provided in the payload will be left unchanged.
     * @param customerId A Voucherify customer&#39;s &#x60;id&#x60; or &#x60;source_id&#x60;. (required)
     * @param customersUpdateRequestBody Specify the parameters to be updated. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a customer object if updates were successful. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomerAsync(String customerId, CustomersUpdateRequestBody customersUpdateRequestBody, final ApiCallback<CustomersUpdateResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCustomerValidateBeforeCall(customerId, customersUpdateRequestBody, _callback);
        Type localVarReturnType = new TypeToken<CustomersUpdateResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomersConsents
     * @param customerId A Voucherify unique customer identifier or source ID. (required)
     * @param body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if the consents were updated successfully. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersConsentsCall(String customerId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/v1/customers/{customerId}/consents"
            .replace("{" + "customerId" + "}", localVarApiClient.escapeString(customerId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomersConsentsValidateBeforeCall(String customerId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customerId' is set
        if (customerId == null) {
            throw new ApiException("Missing the required parameter 'customerId' when calling updateCustomersConsents(Async)");
        }

        return updateCustomersConsentsCall(customerId, body, _callback);

    }

    /**
     * Update Customer&#39;s consents
     * Update marketing permissions for the specified customer.
     * @param customerId A Voucherify unique customer identifier or source ID. (required)
     * @param body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60; (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if the consents were updated successfully. </td><td>  -  </td></tr>
     </table>
     */
    public void updateCustomersConsents(String customerId, Object body) throws ApiException {
        updateCustomersConsentsWithHttpInfo(customerId, body);
    }

    /**
     * Update Customer&#39;s consents
     * Update marketing permissions for the specified customer.
     * @param customerId A Voucherify unique customer identifier or source ID. (required)
     * @param body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60; (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if the consents were updated successfully. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> updateCustomersConsentsWithHttpInfo(String customerId, Object body) throws ApiException {
        okhttp3.Call localVarCall = updateCustomersConsentsValidateBeforeCall(customerId, body, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Update Customer&#39;s consents (asynchronously)
     * Update marketing permissions for the specified customer.
     * @param customerId A Voucherify unique customer identifier or source ID. (required)
     * @param body Key-value pairs where the key is the consent identifier and value is a boolean that identifies if a customer has given the consent or not. To deny all consents use \&quot;unsubscribed\&quot; as a consent identifier and \&quot;true\&quot; as its value.    #### Examples  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;cnst_aIdUulAh0SCsOCaS3005y7yS\&quot;: true,     \&quot;cnst_aIdUulAhwewqaS31213fdsfds\&quot;: false } &#x60;&#x60;&#x60;  Opt-out from all communication:  &lt;!-- title: \&quot;Request Body\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;unsubscribed\&quot;: true } &#x60;&#x60;&#x60; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> Returns no content if the consents were updated successfully. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersConsentsAsync(String customerId, Object body, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCustomersConsentsValidateBeforeCall(customerId, body, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomersInBulk
     * @param customersUpdateInBulkRequestBody Specify the customer fields that you would like to update in each customer object. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersInBulkCall(List<CustomersUpdateInBulkRequestBody> customersUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customersUpdateInBulkRequestBody;

        // create path and map variables
        String localVarPath = "/v1/customers/bulk/async";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomersInBulkValidateBeforeCall(List<CustomersUpdateInBulkRequestBody> customersUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        return updateCustomersInBulkCall(customersUpdateInBulkRequestBody, _callback);

    }

    /**
     * Update Customers in bulk
     * Update several customers in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersUpdateInBulkRequestBody Specify the customer fields that you would like to update in each customer object. (optional)
     * @return CustomersUpdateInBulkResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersUpdateInBulkResponseBody updateCustomersInBulk(List<CustomersUpdateInBulkRequestBody> customersUpdateInBulkRequestBody) throws ApiException {
        ApiResponse<CustomersUpdateInBulkResponseBody> localVarResp = updateCustomersInBulkWithHttpInfo(customersUpdateInBulkRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Customers in bulk
     * Update several customers in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersUpdateInBulkRequestBody Specify the customer fields that you would like to update in each customer object. (optional)
     * @return ApiResponse&lt;CustomersUpdateInBulkResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersUpdateInBulkResponseBody> updateCustomersInBulkWithHttpInfo(List<CustomersUpdateInBulkRequestBody> customersUpdateInBulkRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateCustomersInBulkValidateBeforeCall(customersUpdateInBulkRequestBody, null);
        Type localVarReturnType = new TypeToken<CustomersUpdateInBulkResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Customers in bulk (asynchronously)
     * Update several customers in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersUpdateInBulkRequestBody Specify the customer fields that you would like to update in each customer object. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersInBulkAsync(List<CustomersUpdateInBulkRequestBody> customersUpdateInBulkRequestBody, final ApiCallback<CustomersUpdateInBulkResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCustomersInBulkValidateBeforeCall(customersUpdateInBulkRequestBody, _callback);
        Type localVarReturnType = new TypeToken<CustomersUpdateInBulkResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomersMetadataInBulk
     * @param customersMetadataUpdateInBulkRequestBody List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersMetadataInBulkCall(CustomersMetadataUpdateInBulkRequestBody customersMetadataUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = customersMetadataUpdateInBulkRequestBody;

        // create path and map variables
        String localVarPath = "/v1/customers/metadata/async";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "X-App-Id", "X-App-Token" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomersMetadataInBulkValidateBeforeCall(CustomersMetadataUpdateInBulkRequestBody customersMetadataUpdateInBulkRequestBody, final ApiCallback _callback) throws ApiException {
        return updateCustomersMetadataInBulkCall(customersMetadataUpdateInBulkRequestBody, _callback);

    }

    /**
     * Update Customers&#39; Metadata in bulk
     * Update several customers metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersMetadataUpdateInBulkRequestBody List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs. (optional)
     * @return CustomersMetadataUpdateInBulkResponseBody
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public CustomersMetadataUpdateInBulkResponseBody updateCustomersMetadataInBulk(CustomersMetadataUpdateInBulkRequestBody customersMetadataUpdateInBulkRequestBody) throws ApiException {
        ApiResponse<CustomersMetadataUpdateInBulkResponseBody> localVarResp = updateCustomersMetadataInBulkWithHttpInfo(customersMetadataUpdateInBulkRequestBody);
        return localVarResp.getData();
    }

    /**
     * Update Customers&#39; Metadata in bulk
     * Update several customers metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersMetadataUpdateInBulkRequestBody List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs. (optional)
     * @return ApiResponse&lt;CustomersMetadataUpdateInBulkResponseBody&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CustomersMetadataUpdateInBulkResponseBody> updateCustomersMetadataInBulkWithHttpInfo(CustomersMetadataUpdateInBulkRequestBody customersMetadataUpdateInBulkRequestBody) throws ApiException {
        okhttp3.Call localVarCall = updateCustomersMetadataInBulkValidateBeforeCall(customersMetadataUpdateInBulkRequestBody, null);
        Type localVarReturnType = new TypeToken<CustomersMetadataUpdateInBulkResponseBody>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Customers&#39; Metadata in bulk (asynchronously)
     * Update several customers metadata properties in one asynchronous operation.   In one request, it is possible to update a maximum of **100** records. In the response body, you get a unique async action identifier.    If a requested customer object is not found, then an **upsert** occurs. This is reflected in the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint as follows:    &lt;!-- title: \&quot;Response\&quot; lineNumbers: true --&gt; &#x60;&#x60;&#x60;json {     \&quot;found\&quot;: false,     \&quot;updated\&quot;: true } &#x60;&#x60;&#x60;  This API request starts a process that affects Voucherify data in bulk.   In case of small jobs (like bulk update) the request is put into a queue and processed once every other bulk request placed in the queue prior to this request is finished. However, when the job takes a longer time (like vouchers generation) then it is processed in small portions in a round-robin fashion. When there is a list of vouchers generation scheduled, then they will all have the &#x60;IN_PROGRESS&#x60; status shortly. This way, small jobs added just after scheduling big jobs of the same type will be processed in a short time window.   The result will return the async ID. You can verify the status of your request via this [API request](ref:get-async-action).
     * @param customersMetadataUpdateInBulkRequestBody List the &#x60;source_ids&#x60; of the customer&#39;s you would like to update along with the metadata key value pairs. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Returns ID of the scheduled async action. The response informs you that your request has been accepted and customers will be updated in the repository asynchronously. To check the update status and result, copy the &#x60;async_action_id&#x60; from the response and pass it using the &lt;!-- [Get Async Action](OpenAPI.json/paths/~1async-actions~1{asyncActionId}/get) --&gt;[Get Async Action](ref:get-async-action) endpoint. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomersMetadataInBulkAsync(CustomersMetadataUpdateInBulkRequestBody customersMetadataUpdateInBulkRequestBody, final ApiCallback<CustomersMetadataUpdateInBulkResponseBody> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCustomersMetadataInBulkValidateBeforeCall(customersMetadataUpdateInBulkRequestBody, _callback);
        Type localVarReturnType = new TypeToken<CustomersMetadataUpdateInBulkResponseBody>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
